var documenterSearchIndex = {"docs":
[{"location":"algorithms_P_any_Cmax/#\\text{P}\\text{any}\\text{C}_\\text{max}-1","page":"textPtextanytextC_textmax","title":"textPtextanytextC_textmax","text":"","category":"section"},{"location":"algorithms_P_any_Cmax/#","page":"textPtextanytextC_textmax","title":"textPtextanytextC_textmax","text":"Scheduling.jl provides a few algorithms for the textPtextanytextC_textmax problem.","category":"page"},{"location":"algorithms_P_any_Cmax/#","page":"textPtextanytextC_textmax","title":"textPtextanytextC_textmax","text":"Algorithms.P2_any_Cmax_DL(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.P_any_Cmax_MRT(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.P_any_Cmax_TWY(J::Vector{Job}, M::Vector{Machine})","category":"page"},{"location":"algorithms_P_any_Cmax/#Scheduling.Algorithms.P2_any_Cmax_DL-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextanytextC_textmax","title":"Scheduling.Algorithms.P2_any_Cmax_DL","text":"P2_any_Cmax_DL(J::Vector{Job}, M::Vector{Machine})\n\nThis is an exact pseudopolynomial algorithm for the P2|any|Cmax problem.\n\nReferences\n\nDu, J., & Leung, J. (1989). Complexity of scheduling parallel task systems. SIAM Journal on Discrete Mathematics, 2(4), 473–487. http://doi.org/10.1137/0402042\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P_any_Cmax/#Scheduling.Algorithms.P_any_Cmax_MRT-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextanytextC_textmax","title":"Scheduling.Algorithms.P_any_Cmax_MRT","text":"P_any_Cmax_MRT(J::Vector{Job}, M::Vector{Machine})\n\nThis is a 3/2-approximation algorithm for the P|any|Cmax problem.\n\nReferences\n\nMounié, G., Rapine, C., & Trystram, D. (2007). A 3/2‐Approximation Algorithm for Scheduling Independent Monotonic Malleable Tasks. SIAM Journal on Computing, 37(2), 401–412. http://doi.org/10.1137/S0097539701385995\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P_any_Cmax/#Scheduling.Algorithms.P_any_Cmax_TWY-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextanytextC_textmax","title":"Scheduling.Algorithms.P_any_Cmax_TWY","text":"P_any_Cmax_TWY(J::Vector{Job}, M::Vector{Machine})\n\nReferences\n\nJ. Turek, J. L. Wolf, and P. S. Yu. Approximate Algorithms Scheduling Parallelizable Tasks. In: SPAA. ACM, 1992, pp. 323–332. DOI: 10.1145/140901.141909.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#List-algorithms-1","page":"List algorithms","title":"List algorithms","text":"","category":"section"},{"location":"algorithms_list/#","page":"List algorithms","title":"List algorithms","text":"The Scheduling.jl package provides a set of algorithms based on well-known priority rules. These algorithms are designed for scheduling on identical parallel machines.","category":"page"},{"location":"algorithms_list/#","page":"List algorithms","title":"List algorithms","text":"Algorithms.list!(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.list(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.spt!(J::Vector{Job}, M::Vector{Machine}; weighted = false)\nAlgorithms.spt(J::Vector{Job}, M::Vector{Machine}; weighted = false)\nAlgorithms.wspt!(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.wspt(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.lpt!(J::Vector{Job}, M::Vector{Machine}; weighted = false)\nAlgorithms.lpt(J::Vector{Job}, M::Vector{Machine}; weighted = false)\nAlgorithms.wlpt!(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.wlpt(J::Vector{Job}, M::Vector{Machine})","category":"page"},{"location":"algorithms_list/#Scheduling.Algorithms.list!-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.list!","text":"list!(J::Vector{Job}, M::Vector{Machine})\n\nSchedules jobs in the order of their appearance in the J vector. If more than one machine can be selected, it selects the machine which is first in the M vector. This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see list.\n\nThis algorithm is based on the following job parameters: p (processing time).\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.list-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.list","text":"list(J::Vector{Job}, M::Vector{Machine})\n\nThe same as list!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.spt!-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.spt!","text":"spt!(J::Vector{Job}, M::Vector{Machine}; weighted = false)\n\nSchedules jobs in the order of their processing times, starting with the shortest one. If weighted is set to true, then the sorting will be weighted. This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see spt.\n\nThis algorithm is based on the following job parameters: p (processing time), w (weight).\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.spt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.spt","text":"spt(J::Vector{Job}, M::Vector{Machine}; weighted = false)\n\nThe same as spt!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.wspt!-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.wspt!","text":"wspt!(J::Vector{Job}, M::Vector{Machine})\n\nSchedules jobs in the order of their processing times to weight ratios, starting with the lowest one. This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see wspt.\n\nThis algorithm is based on the following job parameters: p (processing time), w (weight).\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.wspt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.wspt","text":"wspt(J::Vector{Job}, M::Vector{Machine})\n\nThe same as wspt!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.lpt!-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.lpt!","text":"lpt!(J::Vector{Job}, M::Vector{Machine}; weighted = false)\n\nSchedules jobs in the order of their processing times, starting with the largest one. If weighted is set to true, then the sorting will be weighted. This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see lpt.\n\nThis algorithm is based on the following job parameters: p (processing time), w (weight).\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.lpt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.lpt","text":"lpt(J::Vector{Job}, M::Vector{Machine}; weighted = false)\n\nThe same as lpt!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.wlpt!-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.wlpt!","text":"wlpt!(J::Vector{Job}, M::Vector{Machine}; copy = false)\n\nSchedules jobs in the order of their processing times to weight ratios, starting with the highest one. This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see wlpt.\n\nThis algorithm is based on the following job parameters: p (processing time), w (weight).\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.wlpt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.wlpt","text":"wlpt(J::Vector{Job}, M::Vector{Machine})\n\nThe same as wlpt!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#Machines-1","page":"Machines","title":"Machines","text":"","category":"section"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"Another basic structure provided by the Scheduling.jl package is a Machine.","category":"page"},{"location":"scheduling_machines/#Creating-a-single-machine-1","page":"Machines","title":"Creating a single machine","text":"","category":"section"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"In order to create a machine, you may use the Machine constructor. Is is required to pass a machine name to the constructor, but all the other parameters are optional.","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"julia> Machine(\"M\")\nMachine M","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"Machine parameters can be set when the machine is created. However, as Machine is an immutable struct, you are not able to change any of the parameters of an existing job. The structure of the Machine struct is as follows:","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"struct Machine\n    name::String\n    params::MachineParams\nend","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"while the default params are generated based on the following struct.","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"struct ClassicalMachineParams <: MachineParams\n    s::Rational{UInt}   # speed (default: 1)\nend","category":"page"},{"location":"scheduling_machines/#Creating-a-set-of-machines-1","page":"Machines","title":"Creating a set of machines","text":"","category":"section"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"You are provided a few functions that can generate a vector of jobs. A vector of jobs is the basic structure any scheduling algorithm works on. You can create an empty vector of jobs, a vector of a given number of identical jobs or a vector of jobs with arbitrary processing times.","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"Machines()\nMachines(n::Int)\nMachines(P::Array{Rational{Int}, 1})\nMachines(P::Array{Int, 1})","category":"page"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{}","page":"Machines","title":"Scheduling.Machines","text":"Machines()\n\nGenerates an empty vector of Machine{ClassicalMachineParams} elements.\n\nExample\n\njulia> Machines()\nA set of 0 machine(s):\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{Int64}","page":"Machines","title":"Scheduling.Machines","text":"Machines(m::Int)\n\nGenerates a set of m identical parallel machines, denoted by P_1, P_2, etc.\n\nExample\n\njulia> Machines(4)\nA set of 4 machine(s):\n    Machine P_1\n    Machine P_2\n    Machine P_3\n    Machine P_4\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{Array{Rational{Int64},1}}","page":"Machines","title":"Scheduling.Machines","text":"Machines(S::Array{Rational{Int}, 1})\n\nGenerates a set of machines with speeds determined by the S array, denoted by Q_1, Q_2, etc.\n\nExample\n\njulia> Machines([1, 1//2, 2])\nA set of 3 machine(s):\n    Machine Q_1\n    Machine Q_2:     [s = 1//2]\n    Machine Q_3:     [s = 2]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{Array{Int64,1}}","page":"Machines","title":"Scheduling.Machines","text":"Machines(S::Array{Int, 1})\n\nGenerates a set of machines with speeds determined by the S array, denoted by Q_1, Q_2, etc.\n\nExample\n\njulia> Machines([1, 3, 2])\nA set of 3 machine(s):\n    Machine Q_1\n    Machine Q_2:     [s = 3]\n    Machine Q_3:     [s = 2]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"As the set of machines is a vector of Machine elements, you may always extend it by a new one.","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"julia> M = Machines()\nA set of 0 machine(s):\n\njulia> push!(M, Machine(\"M\"))\nA set of 1 machine(s):\n    Machine M\n","category":"page"},{"location":"scheduling_assignments/#Assignments-1","page":"Assignments","title":"Assignments","text":"","category":"section"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"Given a job and a machine, one can assign a job to the machine(s). In order to create an assignment, you need a reference to a job (either a standalone one, or one from a vector), a machine (classical jobs) or a vector of machines (parallel jobs), and job starting and completion times. In case of classical jobs, start and completion times must be rational numbers, while for classical jobs they can be floats.","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"julia> J = Job(\"J\")\nClassical job J:        [p = 1]\n\njulia> M = Machine(\"M\")\nMachine M\n\njulia> JobAssignment(J, M, 2, 4)\nJ → M[2, 4)","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"julia> J = Job(\"J\")\nClassical job J:        [p = 1]\n\njulia> M = Machines(2)\nA set of 2 machine(s):\n        Machine P_1\n        Machine P_2\n\njulia> JobAssignment(J, M, 2, 4)\nJ → P_1 P_2 [2.0, 4.0)","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"Assignments can be stored in vectors.","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"JobAssignments()","category":"page"},{"location":"scheduling_assignments/#Scheduling.JobAssignments-Tuple{}","page":"Assignments","title":"Scheduling.JobAssignments","text":"JobAssignments()\n\nGenerates an empty vector of JobAssignment elements.\n\nExample\n\njulia> JobAssignments()\nA set of 0 assignment(s):\n\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P2__Cmax/#\\text{P}2\\text{C}_\\text{max}-1","page":"textP2textC_textmax","title":"textP2textC_textmax","text":"","category":"section"},{"location":"algorithms_P2__Cmax/#","page":"textP2textC_textmax","title":"textP2textC_textmax","text":"The textP2textC_textmax problem is one of the most popular scheduling problems known. There exist plenty of different algorithms and approaches to solving it or approximating an exact solution, as the problem itself is strongly NP-hard. Scheduling.jl provides a few approximation algorithms for the textP2textC_textmax problem.","category":"page"},{"location":"algorithms_P2__Cmax/#","page":"textP2textC_textmax","title":"textP2textC_textmax","text":"Algorithms.P2__Cmax_SW1(J::Vector{Job}, M::Vector{Machine}; eps = 1//10)\nAlgorithms.P2__Cmax_SW3(J::Vector{Job}, M::Vector{Machine}; eps = 1//10)","category":"page"},{"location":"algorithms_P2__Cmax/#Scheduling.Algorithms.P2__Cmax_SW1-Tuple{Array{Job,1},Array{Machine,1}}","page":"textP2textC_textmax","title":"Scheduling.Algorithms.P2__Cmax_SW1","text":"P2__Cmax_SW1(J::Vector{Job}, M::Vector{Machine}; eps = 1//10)\n\nThis is a (1 + eps)-approximation algorithm for the P2||Cmax problem.\n\nReferences\n\nSchuurman, P., & Woeginger, G. J. (2001), Approximation schemes-a tutorial. Lectures on Scheduling.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P2__Cmax/#Scheduling.Algorithms.P2__Cmax_SW3-Tuple{Array{Job,1},Array{Machine,1}}","page":"textP2textC_textmax","title":"Scheduling.Algorithms.P2__Cmax_SW3","text":"P2__Cmax_SW3(J::Vector{Job}, M::Vector{Machine}; eps = 1//10)\n\nThis is an FPTAS algorithm for the P2||Cmax problem.\n\nReferences\n\nSchuurman, P., & Woeginger, G. J. (2001), Approximation schemes-a tutorial. Lectures on Scheduling.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#\\text{P}\\text{C}_\\text{max}-1","page":"textPtextC_textmax","title":"textPtextC_textmax","text":"","category":"section"},{"location":"algorithms_P__Cmax/#","page":"textPtextC_textmax","title":"textPtextC_textmax","text":"The textPtextC_textmax problem is one of the most popular scheduling problems known. There exist plenty of different algorithms and approaches to solving it or approximating an exact solution, as the problem itself is strongly NP-hard. Scheduling.jl provides a few algorithms for the textPtextC_textmax problem which state a base for extending the package by new ones.","category":"page"},{"location":"algorithms_P__Cmax/#","page":"textPtextC_textmax","title":"textPtextC_textmax","text":"Algorithms.P__Cmax_IP!(J::Vector{Job}, M::Vector{Machine}; optimizer = GLPK.Optimizer)\nAlgorithms.P__Cmax_IP(J::Vector{Job}, M::Vector{Machine}; optimizer = GLPK.Optimizer)\nAlgorithms.P__Cmax_HS!(J::Vector{Job}, M::Vector{Machine}; eps = 1//10, verbose = false)\nAlgorithms.P__Cmax_HS(J::Vector{Job}, M::Vector{Machine}; eps = 1//10, verbose = false)\nAlgorithms.P__Cmax_MR!(J::Vector{Job}, M::Vector{Machine})\nAlgorithms.P__Cmax_MR(J::Vector{Job}, M::Vector{Machine})","category":"page"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_IP!-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_IP!","text":"P__Cmax_IP!(J::Vector{Job}, M::Vector{Machine}; optimizer = GLPK.Optimizer)\n\nSolves the P||Cmax problem by applying the simple IP proposed by Drozdowski (2009, p. 23). By default, the open source GLPK optimizer together with JuMP is used. This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see P__Cmax_IP.\n\nThis algorithm is based on the following job parameters: p (processing time).\n\nReferences\n\nM.Drozdowski, Scheduling for Parallel Processing, Springer-Verlag, London, 2009, ISBN: 978-1-84882-309-9.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_IP-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_IP","text":"P__Cmax_IP(J::Vector{Job}, M::Vector{Machine}; optimizer = GLPK.Optimizer)\n\nThe same as P__Cmax_IP!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_HS!-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_HS!","text":"P__Cmax_HS!(J::Vector{Job}, M::Vector{Machine}; eps = 1//10, verbose = false)\n\nFinds an approximation solution of the P||Cmax problem based on the algorithms proposed by Hochbaum and Shmoys (1987). This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see P__Cmax_HS.\n\nThis algorithm is based on the following job parameters: p (processing time).\n\nReferences\n\nD.S. Hochbaum and D.B. Shmoys, Using dual approximation algorithms for scheduling problems theoretical and practical results, Journal of the ACM, 34(1):144–162 (1987), doi: 10.1145/7531.7535\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_HS-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_HS","text":"P__Cmax_HS(J::Vector{Job}, M::Vector{Machine}; eps = 1//10, verbose = false)\n\nThe same as P__Cmax_HS!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_MR!-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_MR!","text":"P__Cmax_MR!(J::Vector{Job}, M::Vector{Machine})\n\nAn approximation approach to the online version of the P||Cmax problem proposed by Fleischer and Wahl (2000, p. 345). This algorithm works on original J and M vectors which are also returned with the resulting schedule. In order to use copies, see P__Cmax_MR.\n\nThis algorithm is based on the following job parameters: p (processing time).\n\nReferences\n\nR. Fleischer and M. Wahl, On-line scheduling revisited, Journal of Scheduling, 3:343–353 (2000), doi: 10.1002/1099-1425(200011/12)3:6<343::AID-JOS54>3.0.CO;2-2\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_MR-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_MR","text":"P__Cmax_MR(J::Vector{Job}, M::Vector{Machine})\n\nThe same as P__Cmax_MR!, but it copies the input vectors before the algorithm starts.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Jobs-1","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"One of the basic structures processed in the Scheduling.jl package is a Job.","category":"page"},{"location":"scheduling_jobs/#Creating-a-single-job-1","page":"Jobs","title":"Creating a single job","text":"","category":"section"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"In order to create a job, you may use the Job constructor. Is is required to pass a job name to the constructor, but all the other parameters are optional.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"julia> Job(\"J\")\nClassical job J:        [p = 1]","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"As you can see, the default processing time of a job is equal to 1. Of course, job parameters can be set when the job is created. However, as Job is an immutable struct, you are not able to change any of the parameters of an existing job. The structure of the Job struct is as follows:","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"struct Job\n    name::String\n    params::JobParams\nend","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"while the default params are generated based on the following struct.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"struct ClassicalJobParams <: JobParams\n    p::Rational{UInt}     # basic processing time (default: 1)\n    w::Rational{Int}      # weight (default: 1)\n    r::Rational{UInt}     # ready time (default: 0)\n    d::Rational{Int}      # due date (default: Inf)\n    D::Rational{UInt}     # deadline (default: Inf)\nend","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"It is forbidden to create a job for which r + p > D.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"julia> Job(\"J\", ClassicalJobParams(p = 13//2, r = 7//3, d = -3//7))\nClassical job J:        [p = 13//2, r = 7//3, d = -3//7]","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"However, the package also supports parallel jobs. In case you want to define a parallel job, use the following struct.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"struct ParallelJobParams <: JobParams\n    p::Vector{Real}       # processing times        \n    function ParallelJobParams(p)\n        return new(p)\n    end\nend","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"The p vector contains the actual processing times of the job provided that a given number of machines is used. For example, if p = [100, 80, 60, 20, 10], then it would take ten units of time to execute this job on five machines in parallel, but 60 units if the job was executed on three machines in parallel.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"julia> Job(\"J\", ParallelJobParams([10,5]))\nParallel job J:  (p : [10,5])","category":"page"},{"location":"scheduling_jobs/#Creating-a-set-of-jobs-1","page":"Jobs","title":"Creating a set of jobs","text":"","category":"section"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"You are provided a few functions that can generate a vector of jobs. A vector of jobs is the basic structure any scheduling algorithm works on. You can create an empty vector of jobs, a vector of a given number of identical jobs or a vector of jobs with arbitrary processing times.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"Jobs()\nJobs(n::Int)\nJobs(P::Array{Rational{Int}, 1})\nJobs(P::Array{Int, 1})","category":"page"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs()\n\nGenerates an empty vector of Job{ClassicalJobParams} elements.\n\nExample\n\njulia> Jobs()\nA set of 0 job(s):\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{Int64}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs(n::Int)\n\nGenerates a set of n identical unit jobs, denoted by J_1, J_2, etc.\n\nExample\n\njulia> Jobs(4)\nA set of 4 job(s):\n​    Job J_1:    [p = 1]\n    Job J_2:    [p = 1]\n    Job J_3:    [p = 1]\n    Job J_4:    [p = 1]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{Array{Rational{Int64},1}}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs(P::Array{Rational{Int}, 1})\n\nGenerates a set of jobs with basic processing times determined by the P array, denoted by J_1, J_2, etc.\n\nExample\n\njulia> Jobs([1//2, 3, 5//3, 7])\nA set of 4 job(s):\n​    Job J_1:    [p = 1//2]\n    Job J_2:    [p = 3]\n    Job J_3:    [p = 5//3]\n    Job J_4:    [p = 7]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{Array{Int64,1}}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs(P::Array{Int, 1})\n\nGenerates a set of jobs with basic processing times determined by the P array, denoted by J_1, J_2, etc.\n\nExample\n\njulia> Jobs([1, 5, 6, 2])\nA set of 4 job(s):\n    Job J_1:    [p = 1]\n    Job J_2:    [p = 5]\n    Job J_3:    [p = 6]\n    Job J_4:    [p = 2]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"As the set of jobs is a vector of Job elements, you may always extend it by a new one.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"julia> J = Jobs()\nA set of 0 job(s):\n\njulia> push!(J, Job(\"J\"))\nA set of 1 job(s):\n        Classical job J:        [p = 1]\n","category":"page"},{"location":"scheduling_objectives/#Objective-functions-1","page":"Objective functions","title":"Objective functions","text":"","category":"section"},{"location":"scheduling_objectives/#","page":"Objective functions","title":"Objective functions","text":"Given a schedule, one can find its objective value based on one of the following functions from the Scheduling.Objectives submodule. After the module is loaded, the function names are in the global scope.","category":"page"},{"location":"scheduling_objectives/#","page":"Objective functions","title":"Objective functions","text":"cmax(S::Schedule)\ncsum(S::Schedule; weighted = false)\nwcsum(S::Schedule)\nlmax(S::Schedule)\nnt(S::Schedule; weighted = false)\nwnt(S::Schedule)\ntsum(S::Schedule; weighted = false)\nwtsum(S::Schedule)","category":"page"},{"location":"scheduling_objectives/#Scheduling.Objectives.cmax-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.cmax","text":"cmax(S::Schedule)\n\nReturns the maximum completion time in schedule S.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.csum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.csum","text":"csum(S::Schedule; weighted = false)\n\nReturns the total completion time of these jobs in schedule S which are referenced in the S.jobs vector. If weighted is set to true, then the result will be weighted.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.wcsum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.wcsum","text":"wcsum(S::Schedule)\n\nReturns the total weighted completion time of these jobs in schedule S which are referenced in the S.jobs vector. It is an alias for csum(S::Schedule, weighted = true).\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.lmax-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.lmax","text":"lmax(S::Schedule)\n\nReturns the maximum lateness in schedule S. If the schedule is empty, then the function returns -Inf.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.nt-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.nt","text":"nt(S::Schedule; weighted = false)\n\nReturns the number of tardy jobs in schedule S which are referenced in the S.jobs vector. If weighted is set to true, then the result will be weighted.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.wnt-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.wnt","text":"wnt(S::Schedule)\n\nReturns the number of tardy jobs in schedule S which are referenced in the S.jobs vector. It is an alias for nt(S::Schedule, weighted = true).\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.tsum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.tsum","text":"tsum(S::Schedule; weighted = false)\n\nReturns the total tardiness of these jobs in schedule S which are referenced in the S.jobs vector. If weighted is set to true, then the result will be weighted.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.wtsum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.wtsum","text":"wtsum(S::Schedule)\n\nReturns the total tardiness of these jobs in schedule S which are referenced in the S.jobs vector. It is an alias for tsum(S::Schedule, weighted = true).\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Here we show a few useful examples for the Scheduling package.","category":"page"},{"location":"examples/#Comparing-algorithms-1","page":"Examples","title":"Comparing algorithms","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"In this example, we randomly choose 20 instances of the textPtextC_textmax problem and then compare the solutions generated by an exact algorithm, the LPT rule and the approximation algorithm by Hochbaum & Shmoys.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Random\nusing Scheduling, Scheduling.Algorithms, Scheduling.Objectives\n\n# We generate 20 instances\nfor instance_id in 1:20\n    # Generate the set of machines\n    M = Machines(rand(2:6))\n    # Generate the set of 12--20 jobs\n    J = Jobs(rand(1:50, rand(12:20)))\n\n    # Generate an exact solution\n    S1 = Algorithms.P__Cmax_IP(J, M)\n    # Generate a heuristic solution\n    S2 = Algorithms.lpt(J, M)\n    # Generate an approximation\n    S3 = Algorithms.P__Cmax_HS(J, M)\n\n    # Print the summary\n    println(\"Instance $(instance_id):\")\n    println(\"   Optimal solution:         $(float(cmax(S1)))\")\n    println(\"   Heuristic:                $(float(cmax(S2)))\")\n    println(\"   Heuristic approx. ratio:  $(float(cmax(S2)//cmax(S1)))\")\n    println(\"   H&S:                      $(float(cmax(S3)))\")\n    println(\"   H&S approx. ratio:        $(float(cmax(S3)//cmax(S1)))\")\nend","category":"page"},{"location":"examples/#Saving-and-loading-a-schedule-1","page":"Examples","title":"Saving and loading a schedule","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Scheduling\nusing Scheduling.Algorithms\n\n# Generate a set of jobs with processing times from an array\nJ = Jobs([27, 19, 19, 4, 48, 38, 29, 21, 9, 22, 11, 27, 36, 34, 21, 7, 7, 28])\n# Generate a set of 4 identical machines\nM = Machines(4)\n\n# Generate an optimal schedule using IP\nS = Algorithms.P__Cmax_IP(J, M)\n\n# Save the schedule into the file\nScheduling.save(S, \"my_optimal_schedule.jdl\")\n\n# Load the saved schedule to another variable\nT = Scheduling.load(\"my_optimal_schedule.jdl\")\n\n# Plot the loaded schedule\nScheduling.plot(T)","category":"page"},{"location":"scheduling_schedules/#Schedules-1","page":"Schedules","title":"Schedules","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A schedule (in the sense of Scheduling.jl package) consists of three parts:","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"a vector of jobs,\na vector of machines,\na vector of job assignments.","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"mutable struct Schedule\n    jobs::Vector{Job}\n    machines::Vector{Machine}\n    assignments::Vector{JobAssignment}\nend","category":"page"},{"location":"scheduling_schedules/#Creating-a-schedule-1","page":"Schedules","title":"Creating a schedule","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A schedule can be created easily by assigning vectors of jobs, machines, and assignments to a structure of Schedule type.","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"julia> M = Machines()\nA set of 0 machine(s):\n\njulia> push!(M, Machine(\"M\"))\nA set of 1 machine(s):\n    Machine M\n","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"note: Note\nWhen creating a schedule, take the following guidelines into account:It is highly recommended, for further compatibility purposes, that any job reference in the assignments vector is also stored in the jobs vector. The same rule applies to machines.\nThe machines vector is used when a plotting/exporting function is called. If there exists an assignment of a job to a machine, such that the reference to the machine is not stored in the machines vector, then the behavior of the plotting/exporting function may be unexpected.","category":"page"},{"location":"scheduling_schedules/#Plotting/exporting-a-schedule-1","page":"Schedules","title":"Plotting/exporting a schedule","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A schedule can be plotted (using PyPlot) or exported (as a TeX file).","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"Scheduling.plot(S::Schedule;\n     animate = false, sizex = 800, sizey = 500,\n     output_file::String = \"Schedule.gif\", fps = 1)\nScheduling.TeX(S::Schedule, output_file::String = \"Schedule.tex\"; compile = false)","category":"page"},{"location":"scheduling_schedules/#Scheduling.plot-Tuple{Schedule}","page":"Schedules","title":"Scheduling.plot","text":"plot(S::Schedule;\n     animate = false, sizex = 800, sizey = 500,\n     output_file::String = \"Schedule.gif\", fps = 1)\n\nPlots a schedule. The optional arguments are taken into account if animate is set to true. Then, a gif file is generated.\n\nExamples\n\njulia> Scheduling.plot(S)\njulia> Scheduling.plot(S, animate = true)\n\n\n\n\n\n","category":"method"},{"location":"scheduling_schedules/#Scheduling.TeX","page":"Schedules","title":"Scheduling.TeX","text":"TeX(S::Schedule, output_file::String = \"Schedule.tex\"; compile = false)\n\nGenerates a TeX file with a tikz representation of a schedule. An optional parameter compile determines whether the output file should be automatically compiled using pdflatex. If the output_file exists, then it will be replaced without any prompt. All the intermediate directories will be created if needed.\n\nExamples\n\njulia> Scheduling.TeX(S, \"/absolute/path/to/the/file.tex\")\njulia> Scheduling.TeX(S, \"../relative/path/to/the/file.tex\", compile = true)\n\n\n\n\n\n","category":"function"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"note: Note\nIf you generate a schedule for parallel jobs, then keep in mind that at the moment the plot function assumes that the machines are consecutive and that they are listed in the increasing order.","category":"page"},{"location":"scheduling_schedules/#Saving/loading-a-schedule-1","page":"Schedules","title":"Saving/loading a schedule","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A Schedule structure can be easily saved to a file and then loaded back. The Scheduling package uses the HDF5 binary files to store structures.","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"Scheduling.save(S::Schedule, output_file::String = \"Schedule.jld\")\nScheduling.load(input_file::String = \"Schedule.jld\")","category":"page"},{"location":"scheduling_schedules/#Scheduling.save","page":"Schedules","title":"Scheduling.save","text":"save(S::Schedule, output_file::String = \"Schedule.jld\")\n\nSaves a schedule to a file so it can be reloaded later.\n\n\n\n\n\n","category":"function"},{"location":"scheduling_schedules/#Scheduling.load","page":"Schedules","title":"Scheduling.load","text":"load(input_file::String = \"Schedule.jld\")\n\nLoads a schedule from a file. Return a reference to a loaded schedule.\n\n\n\n\n\n","category":"function"},{"location":"#Scheduling.jl-1","page":"Introduction","title":"Scheduling.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Scheduling.jl is a pure Julia package that can be seen as a framework for scheduling research. It is maintained by Sascha Hunold (TU Wien) and Bartlomiej Przybylski (AMU Poznan).","category":"page"},{"location":"#Features-1","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"At the moment the package provides a limited amount of functionalities.","category":"page"},{"location":"#Scheduling-1","page":"Introduction","title":"Scheduling","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Scheduling is a main module of the package. It provides:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"a set of structures for representing:\nfixed processing times jobs,\nparallel machines,\nschedules,\nfunctions for plotting a schedule and exporting it as a TeX file,\nfunctions for saving a schedule into an HDF5 binary file and loading it back from such a file.","category":"page"},{"location":"#Scheduling.Objectives-1","page":"Introduction","title":"Scheduling.Objectives","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The Scheduling.Objectives module provides a number of objective functions that can be used to estimate the quality of a schedule.","category":"page"},{"location":"#Scheduling.Algorithms-1","page":"Introduction","title":"Scheduling.Algorithms","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This module provides a set of implementations of the scheduling algorithms. These algorithms may be used to transform a set of jobs and machines into a schedule based on exact, heuristic or approximation approach. The list of algorithms include the standard list algorithms like LPT, SPT, WLPT and WSPT.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Moreover, we implemented a few exact and approximation algorithms for the textPtextC_textmax and textPtextanytextC_textmax problems.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"To use Scheduling we require Julia 1.0 or higher. Please see http://julialang.org/downloads for instructions on how to obtain Julia for your system. In order to install the Scheduling package, simply type:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using Pkg; Pkg.add(\"Scheduling\")","category":"page"},{"location":"#Quick-start-1","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The following example shows how to use some of the functionalities provided by the Scheduling.jl package","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using Scheduling # We need the basic structures\nusing Scheduling.Algorithms # We will use some predefined algorithms\nusing Scheduling.Objectives # We will estimate the quality of the resulting schedules\n\n# Generate a set of jobs with processing times from an array\nJ = Jobs([27, 19, 19, 4, 48, 38, 29, 21, 9, 22, 11, 27, 36, 34, 21, 7, 7, 28])\n# Generate a set of 4 identical machines\nM = Machines(4)\n\n# Generate an optimal schedule using IP\nOPT = Algorithms.P__Cmax_IP(J, M)\n# As all the numbers are rational and we expect the length\n# of the schedule to have integer time, we need to convert\n# the Cmax value\nprintln(\"Optimal schedule:     Cmax = $(Int(cmax(OPT)))\")\n\n# Generate a schedule using LPT list rule\nLPT = Algorithms.lpt(J, M)\nprintln(\"LPT schedule:         Cmax = $(Int(cmax(LPT)))\")\n\n# Generate a schedule using SPT list rule\nSPT = Algorithms.spt(J, M)\nprintln(\"SPT schedule:         Cmax = $(Int(cmax(SPT)))\")\n\n# Generate a schedule using the Hochbaum-Shmoys algorithm\nHS = Algorithms.P__Cmax_HS(J, M, eps = 1//3)\nprintln(\"HS schedule:          Cmax = $(Int(cmax(HS)))\")\n\n# Plot the optimal schedule\nScheduling.plot(OPT)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The output will be:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Optimal schedule:     Cmax = 102\nLPT schedule:         Cmax = 104\nSPT schedule:         Cmax = 125\nHS schedule:          Cmax = 124","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and then the optimal plot will be generated by the PyPlot package.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please note that the functions copy the input vectors before they execute the algorithm. If you want to prevent that, you may call respective functions ending with !, e.g. P__Cmax_HS!.","category":"page"}]
}
