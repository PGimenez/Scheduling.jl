var documenterSearchIndex = {"docs":
[{"location":"algorithms_P__Cmax/#\\text{P}\\text{C}_\\text{max}-1","page":"textPtextC_textmax","title":"textPtextC_textmax","text":"","category":"section"},{"location":"algorithms_P__Cmax/#","page":"textPtextC_textmax","title":"textPtextC_textmax","text":"The textPtextC_textmax problem is one of the most popular scheduling problems known. There exist plenty of different algorithms and approaches to solving it or approximating an exact solution, as the problem itself is strongly NP-hard. Scheduling.jl provides a few algorithms for the textPtextC_textmax problem which state a base for extending the package by new ones.","category":"page"},{"location":"algorithms_P__Cmax/#","page":"textPtextC_textmax","title":"textPtextC_textmax","text":"Algorithms.P__Cmax_IP(J::Vector{Job}, M::Vector{Machine}; optimizer = GLPK.Optimizer, copy = false)\nAlgorithms.P__Cmax_HS(J::Vector{Job}, M::Vector{Machine}; eps = 1//10, copy = false, verbose = false)\nAlgorithms.P__Cmax_MR(J::Vector{Job}, M::Vector{Machine}; copy = false)","category":"page"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_IP-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_IP","text":"P__Cmax_IP(J::Vector{Job}, M::Vector{Machine}; optimizer = GLPK.Optimizer, copy = false)\n\nSolves the P||Cmax problem by applying the simple IP proposed by Drozdowski (2009, p. 23). By default, the open source GLPK optimizer together with JuMP is used. If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\nReferences\n\nM.Drozdowski, Scheduling for Parallel Processing, Springer-Verlag, London, 2009, ISBN: 978-1-84882-309-9.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_HS-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_HS","text":"P__Cmax_HS(J::Vector{Job}, M::Vector{Machine}; eps = 1//10, copy = false, verbose = false)\n\nFinds an approximation solution of the P||Cmax problem based on the algorithms proposed by Hochbaum and Shmoys (1987). If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\nReferences\n\nD.S. Hochbaum and D.B. Shmoys, Using dual approximation algorithms for scheduling problems theoretical and practical results, Journal of the ACM, 34(1):144–162 (1987), doi: 10.1145/7531.7535\n\n\n\n\n\n","category":"method"},{"location":"algorithms_P__Cmax/#Scheduling.Algorithms.P__Cmax_MR-Tuple{Array{Job,1},Array{Machine,1}}","page":"textPtextC_textmax","title":"Scheduling.Algorithms.P__Cmax_MR","text":"P__Cmax_MR(J::Vector{Job}, M::Vector{Machine}; copy = false)\n\nAn approximation approach to the online version of the P||Cmax problem proposed by Fleischer and Wahl (2000, p. 345). If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\nReferences\n\nR. Fleischer and M. Wahl, On-line scheduling revisited, Journal of Scheduling, 3:343–353 (2000), doi: 10.1002/1099-1425(200011/12)3:6<343::AID-JOS54>3.0.CO;2-2\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#List-algorithms-1","page":"List algorithms","title":"List algorithms","text":"","category":"section"},{"location":"algorithms_list/#","page":"List algorithms","title":"List algorithms","text":"The Scheduling.jl package provides a set of algorithms based on well-known priority rules. These algorithms are designed for scheduling on identical parallel machines.","category":"page"},{"location":"algorithms_list/#","page":"List algorithms","title":"List algorithms","text":"Algorithms.list(J::Vector{Job}, M::Vector{Machine}; copy = false)\nAlgorithms.spt(J::Vector{Job}, M::Vector{Machine}; weighted = false, copy = false)\nAlgorithms.wspt(J::Vector{Job}, M::Vector{Machine}; copy = false)\nAlgorithms.lpt(J::Vector{Job}, M::Vector{Machine}; weighted = false, copy = false)\nAlgorithms.wlpt(J::Vector{Job}, M::Vector{Machine}; copy = false)","category":"page"},{"location":"algorithms_list/#Scheduling.Algorithms.list-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.list","text":"list(J::Vector{Job}, M::Vector{Machine}; copy = false)\n\nSchedules jobs in the order of their appearance in the J vector. If more than one machine can be selected, it selects the machine which is first in the M vector. If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.spt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.spt","text":"spt(J::Vector{Job}, M::Vector{Machine}; weighted = false, copy = false)\n\nSchedules jobs in the order of their processing times, starting with the shortest one. If weighted is set to true, then the sorting will be weighted. If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.wspt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.wspt","text":"wspt(J::Vector{Job}, M::Vector{Machine}; copy = false)\n\nSchedules jobs in the order of their processing times to weight ratios, starting with the lowest one. If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.lpt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.lpt","text":"lpt(J::Vector{Job}, M::Vector{Machine}; weighted = false, copy = false)\n\nSchedules jobs in the order of their processing times, starting with the largest one. If weighted is set to true, then the sorting will be weighted. If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"algorithms_list/#Scheduling.Algorithms.wlpt-Tuple{Array{Job,1},Array{Machine,1}}","page":"List algorithms","title":"Scheduling.Algorithms.wlpt","text":"wlpt(J::Vector{Job}, M::Vector{Machine}; copy = false)\n\nSchedules jobs in the order of their processing times to weight ratios, starting with the highest one. If copy is set to true, then the returned structure will refer to the copies of the input vectors.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_assignments/#Assignments-1","page":"Assignments","title":"Assignments","text":"","category":"section"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"Given a job and a machine, one can assign a job to the machine. In order to create an assignment, you need a reference to a job (either a standalone one, or one from a vector), a reference to a machine, a starting time and a completion time.","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"mutable struct JobAssignment\n    J::Job\n    M::Machine\n    S::Rational{UInt}     # starting time\n    C::Rational{UInt}     # completion time\nend","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"It is expected that S < C. Otherwise, an error will occur.","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"julia> J = Job(\"J\")\nJob J:  [p = 1]\n\njulia> M = Machine(\"M\")\nMachine M\n\njulia> JobAssignment(J, M, 2, 4)\nJ → M[2, 4)\n","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"Assignments can be stored in vectors.","category":"page"},{"location":"scheduling_assignments/#","page":"Assignments","title":"Assignments","text":"JobAssignments()","category":"page"},{"location":"scheduling_assignments/#Scheduling.JobAssignments-Tuple{}","page":"Assignments","title":"Scheduling.JobAssignments","text":"JobAssignments()\n\nGenerates an empty vector of JobAssignment elements.\n\nExample\n\njulia> JobAssignments()\nA set of 0 assignment(s):\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Jobs-1","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"One of the basic structures processed in the Scheduling.jl package is a Job.","category":"page"},{"location":"scheduling_jobs/#Creating-a-single-job-1","page":"Jobs","title":"Creating a single job","text":"","category":"section"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"In order to create a job, you may use the Job constructor. Is is required to pass a job name to the constructor, but all the other parameters are optional.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"julia> Job(\"J\")\nJob J:  [p = 1]","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"As you can see, the default processing time of a job is equal to 1. Of course, job parameters can be set when the job is created. However, as Job is an immutable struct, you are not able to change any of the parameters of an existing job. Below we present all the possible parameters together with their default values:","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"struct Job\n    name::String\n    p::Rational{UInt}     # basic processing time (default: 1)\n    w::Rational{Int}      # weight (default: 1)\n    r::Rational{UInt}     # ready time (default: 0)\n    d::Rational{Int}      # due date (default: Inf)\n    D::Rational{UInt}     # deadline (default: Inf)\nend","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"It is forbidden to create a job for which r + p > D.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"julia> Job(\"J\", p = 13//2, r = 7//3, d = -3//7)\nJob J:  [p = 13//2, r = 7//3, d = -3//7]","category":"page"},{"location":"scheduling_jobs/#Creating-a-set-of-jobs-1","page":"Jobs","title":"Creating a set of jobs","text":"","category":"section"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"You are provided a few functions that can generate a vector of jobs. A vector of jobs is the basic structure any scheduling algorithm works on. You can create an empty vector of jobs, a vector of a given number of identical jobs or a vector of jobs with arbitrary processing times.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"Jobs()\nJobs(n::Int)\nJobs(P::Array{Rational{Int}, 1})\nJobs(P::Array{Int, 1})","category":"page"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs()\n\nGenerates an empty vector of Job elements.\n\nExample\n\njulia> Jobs()\nA set of 0 job(s):\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{Int64}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs(n::Int)\n\nGenerates a set of n identical unit jobs, denoted by J_1, J_2, etc.\n\nExample\n\njulia> Jobs(4)\nA set of 4 job(s):\n    Job J_1:    [p = 1]\n    Job J_2:    [p = 1]\n    Job J_3:    [p = 1]\n    Job J_4:    [p = 1]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{Array{Rational{Int64},1}}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs(P::Array{Rational{Int}, 1})\n\nGenerates a set of jobs with basic processing times determined by the P array, denoted by J_1, J_2, etc.\n\nExample\n\njulia> Jobs([1//2, 3, 5//3, 7])\nA set of 4 job(s):\n    Job J_1:    [p = 1//2]\n    Job J_2:    [p = 3]\n    Job J_3:    [p = 5//3]\n    Job J_4:    [p = 7]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#Scheduling.Jobs-Tuple{Array{Int64,1}}","page":"Jobs","title":"Scheduling.Jobs","text":"Jobs(P::Array{Int, 1})\n\nGenerates a set of jobs with basic processing times determined by the P array, denoted by J_1, J_2, etc.\n\nExample\n\njulia> Jobs([1, 5, 6, 2])\nA set of 4 job(s):\n    Job J_1:    [p = 1]\n    Job J_2:    [p = 5]\n    Job J_3:    [p = 6]\n    Job J_4:    [p = 2]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"As the set of jobs is a vector of Job elements, you may always extend it by a new one.","category":"page"},{"location":"scheduling_jobs/#","page":"Jobs","title":"Jobs","text":"julia> J = Jobs()\nA set of 0 job(s):\n\njulia> push!(J, Job(\"J\"))\nA set of 1 job(s):\n    Job J:  [p = 1]\n","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Here we show a few useful examples for the Scheduling package.","category":"page"},{"location":"examples/#Comparing-algorithms-1","page":"Examples","title":"Comparing algorithms","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"In this example, we randomly choose 20 instances of the textPtextC_textmax problem and then compare the solutions generated by an exact algorithm, the LPT rule and the approximation algorithm by Hochbaum & Shmoys.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Random\nusing Scheduling, Scheduling.Algorithms, Scheduling.Objectives\n\n# We generate 20 instances\nfor instance_id in 1:20\n    # Generate the set of machines\n    M = Machines(rand(2:6))\n    # Generate the set of 12--20 jobs\n    J = Jobs(rand(1:50, rand(12:20)))\n\n    # Generate an exact solution\n    S1 = Algorithms.P__Cmax_IP(J, M)\n    # Generate a heuristic solution\n    S2 = Algorithms.lpt(J, M)\n    # Generate an approximation\n    S3 = Algorithms.P__Cmax_HS(J, M)\n\n    # Print the summary\n    println(\"Instance $(instance_id):\")\n    println(\"   Optimal solution:         $(float(cmax(S1)))\")\n    println(\"   Heuristic:                $(float(cmax(S2)))\")\n    println(\"   Heuristic approx. ratio:  $(float(cmax(S2)//cmax(S1)))\")\n    println(\"   H&S:                      $(float(cmax(S3)))\")\n    println(\"   H&S approx. ratio:        $(float(cmax(S3)//cmax(S1)))\")\nend","category":"page"},{"location":"examples/#Saving-and-loading-a-schedule-1","page":"Examples","title":"Saving and loading a schedule","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Scheduling\nusing Scheduling.Algorithms\n\n# Generate a set of jobs with processing times from an array\nJ = Jobs([27, 19, 19, 4, 48, 38, 29, 21, 9, 22, 11, 27, 36, 34, 21, 7, 7, 28])\n# Generate a set of 4 identical machines\nM = Machines(4)\n\n# Generate an optimal schedule using IP\nS = Algorithms.P__Cmax_IP(J, M)\n\n# Save the schedule into the file\nScheduling.save(S, \"my_optimal_schedule.jdl\")\n\n# Load the saved schedule to another variable\nT = Scheduling.load(\"my_optimal_schedule.jdl\")\n\n# Plot the loaded schedule\nScheduling.plot(T)","category":"page"},{"location":"scheduling_objectives/#Objective-functions-1","page":"Objective functions","title":"Objective functions","text":"","category":"section"},{"location":"scheduling_objectives/#","page":"Objective functions","title":"Objective functions","text":"Given a schedule, one can find its objective value based on one of the following functions from the Scheduling.Objectives submodule. After the module is loaded, the function names are in the global scope.","category":"page"},{"location":"scheduling_objectives/#","page":"Objective functions","title":"Objective functions","text":"cmax(S::Schedule)\ncsum(S::Schedule; weighted = false)\nwcsum(S::Schedule)\nlmax(S::Schedule)\nnt(S::Schedule; weighted = false)\nwnt(S::Schedule)\ntsum(S::Schedule; weighted = false)\nwtsum(S::Schedule)","category":"page"},{"location":"scheduling_objectives/#Scheduling.Objectives.cmax-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.cmax","text":"cmax(S::Schedule)\n\nReturns the maximum completion time in schedule S.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.csum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.csum","text":"csum(S::Schedule; weighted = false)\n\nReturns the total completion time of these jobs in schedule S which are referenced in the S.jobs vector. If weighted is set to true, then the result will be weighted.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.wcsum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.wcsum","text":"wcsum(S::Schedule)\n\nReturns the total weighted completion time of these jobs in schedule S which are referenced in the S.jobs vector. It is an alias for csum(S::Schedule, weighted = true).\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.lmax-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.lmax","text":"lmax(S::Schedule)\n\nReturns the maximum lateness in schedule S. If the schedule is empty, then the function returns -Inf.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.nt-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.nt","text":"nt(S::Schedule; weighted = false)\n\nReturns the number of tardy jobs in schedule S which are referenced in the S.jobs vector. If weighted is set to true, then the result will be weighted.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.wnt-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.wnt","text":"wnt(S::Schedule)\n\nReturns the number of tardy jobs in schedule S which are referenced in the S.jobs vector. It is an alias for nt(S::Schedule, weighted = true).\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.tsum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.tsum","text":"tsum(S::Schedule; weighted = false)\n\nReturns the total tardiness of these jobs in schedule S which are referenced in the S.jobs vector. If weighted is set to true, then the result will be weighted.\n\n\n\n\n\n","category":"method"},{"location":"scheduling_objectives/#Scheduling.Objectives.wtsum-Tuple{Schedule}","page":"Objective functions","title":"Scheduling.Objectives.wtsum","text":"wtsum(S::Schedule)\n\nReturns the total tardiness of these jobs in schedule S which are referenced in the S.jobs vector. It is an alias for tsum(S::Schedule, weighted = true).\n\n\n\n\n\n","category":"method"},{"location":"scheduling_schedules/#Schedules-1","page":"Schedules","title":"Schedules","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A schedule (in the sense of Scheduling.jl package) consists of three parts:","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"a vector of jobs,\na vector of machines,\na vector of job assignments.","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"mutable struct Schedule\n    jobs::Vector{Job}\n    machines::Vector{Machine}\n    assignments::Vector{JobAssignment}\nend","category":"page"},{"location":"scheduling_schedules/#Creating-a-schedule-1","page":"Schedules","title":"Creating a schedule","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A schedule can be created easily by assigning vectors of jobs, machines, and assignments to a structure of Schedule type.","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"julia> M = Machines()\nA set of 0 machine(s):\n\njulia> push!(M, Machine(\"M\"))\nA set of 1 machine(s):\n    Machine M\n","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"note: Note\nWhen creating a schedule, take the following guidelines into account:It is highly recommended, for further compatibility purposes, that any job reference in the assignments vector is also stored in the jobs vector. The same rule applies to machines.\nThe machines vector is used when a plotting/exporting function is called. If there exists an assignment of a job to a machine, such that the reference to the machine is not stored in the machines vector, then the behavior of the plotting/exporting function may be unexpected.","category":"page"},{"location":"scheduling_schedules/#Plotting/exporting-a-schedule-1","page":"Schedules","title":"Plotting/exporting a schedule","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A schedule can be plotted (using PyPlot) or exported (as a TeX file).","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"Scheduling.plot(S::Schedule;\n     animate = false, sizex = 800, sizey = 500,\n     output_file::String = \"Schedule.gif\", fps = 1)\nScheduling.TeX(S::Schedule, output_file::String = \"Schedule.tex\"; compile = false)","category":"page"},{"location":"scheduling_schedules/#Scheduling.plot-Tuple{Schedule}","page":"Schedules","title":"Scheduling.plot","text":"plot(S::Schedule;\n     animate = false, sizex = 800, sizey = 500,\n     output_file::String = \"Schedule.gif\", fps = 1)\n\nPlots a schedule. The optional arguments are taken into account if animate is set to true. Then, a gif file is generated.\n\nExamples\n\njulia> Scheduling.plot(S)\njulia> Scheduling.plot(S, animate = true)\n\n\n\n\n\n","category":"method"},{"location":"scheduling_schedules/#Scheduling.TeX","page":"Schedules","title":"Scheduling.TeX","text":"TeX(S::Schedule, output_file::String = \"Schedule.tex\"; compile = false)\n\nGenerates a TeX file with a tikz representation of a schedule. An optional parameter compile determines whether the output file should be automatically compiled using pdflatex. If the output_file exists, then it will be replaced without any prompt. All the intermediate directories will be created if needed.\n\nExamples\n\njulia> Scheduling.TeX(S, \"/absolute/path/to/the/file.tex\")\njulia> Scheduling.TeX(S, \"../relative/path/to/the/file.tex\", compile = true)\n\n\n\n\n\n","category":"function"},{"location":"scheduling_schedules/#Saving/loading-a-schedule-1","page":"Schedules","title":"Saving/loading a schedule","text":"","category":"section"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"A Schedule structure can be easily saved to a file and then loaded back. The Scheduling package uses the HDF5 binary files to store structures.","category":"page"},{"location":"scheduling_schedules/#","page":"Schedules","title":"Schedules","text":"Scheduling.save(S::Schedule, output_file::String = \"Schedule.jld\")\nScheduling.load(input_file::String = \"Schedule.jld\")","category":"page"},{"location":"scheduling_schedules/#Scheduling.save","page":"Schedules","title":"Scheduling.save","text":"save(S::Schedule, output_file::String = \"Schedule.jld\")\n\nSaves a schedule to a file so it can be reloaded later.\n\n\n\n\n\n","category":"function"},{"location":"scheduling_schedules/#Scheduling.load","page":"Schedules","title":"Scheduling.load","text":"load(input_file::String = \"Schedule.jld\")\n\nLoads a schedule from a file. Return a reference to a loaded schedule.\n\n\n\n\n\n","category":"function"},{"location":"#Scheduling.jl-1","page":"Introduction","title":"Scheduling.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Scheduling.jl is a pure Julia package that can be seen as a framework for scheduling research. It is maintained by Sascha Hunold (TU Wien) and Bartlomiej Przybylski (AMU Poznan).","category":"page"},{"location":"#Features-1","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"As of version 0.1.1 the package provides a limited amount of functionalities.","category":"page"},{"location":"#Scheduling-1","page":"Introduction","title":"Scheduling","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Scheduling is a main module of the package. It provides:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"a set of structures for representing:\nfixed processing times jobs,\nparallel machines,\nschedules,\nfunctions for plotting a schedule and exporting it as a TeX file,\nfunctions for saving a schedule into an HDF5 binary file and loading it back from such a file.","category":"page"},{"location":"#Scheduling.Objectives-1","page":"Introduction","title":"Scheduling.Objectives","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The Scheduling.Objectives module provides a number of objective functions that can be used to estimate the quality of a schedule.","category":"page"},{"location":"#Scheduling.Algorithms-1","page":"Introduction","title":"Scheduling.Algorithms","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This module provides a set of implementations of the scheduling algorithms. These algorithms may be used to transform a set of jobs and machines into a schedule based on exact, heuristic or approximation approach. The list of algorithms include the standard list algorithms like LPT, SPT, WLPT and WSPT.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Moreover, as of version 0.1.1, a few algorithms for the textPtextC_textmax problem are implemented:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"an exact algorithm based on the Integer Program,\nan approximation algorithm by Hochbaum & Shmoys,\nan on-line MR algorithm for the same problem by Fleischer & Wahl.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"To use Scheduling we require Julia 1.0 or higher. Please see http://julialang.org/downloads for instructions on how to obtain Julia for your system. In order to install the Scheduling package, simply type:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using Pkg; Pkg.add(\"Scheduling\")","category":"page"},{"location":"#Quick-start-1","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The following example shows how to use some of the functionalities provided by the Scheduling.jl package","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using Scheduling # We need the basic structures\nusing Scheduling.Algorithms # We will use some predefined algorithms\nusing Scheduling.Objectives # We will estimate the quality of the resulting schedules\n\n# Generate a set of jobs with processing times from an array\nJ = Jobs([27, 19, 19, 4, 48, 38, 29, 21, 9, 22, 11, 27, 36, 34, 21, 7, 7, 28])\n# Generate a set of 4 identical machines\nM = Machines(4)\n\n# Generate an optimal schedule using IP\nOPT = Algorithms.P__Cmax_IP(J, M)\n# As all the numbers are rational and we expect the length\n# of the schedule to have integer time, we need to convert\n# the Cmax value\nprintln(\"Optimal schedule:     Cmax = $(Int(cmax(OPT)))\")\n\n# Generate a schedule using LPT list rule\nLPT = Algorithms.lpt(J, M)\nprintln(\"LPT schedule:         Cmax = $(Int(cmax(LPT)))\")\n\n# Generate a schedule using SPT list rule\nSPT = Algorithms.spt(J, M)\nprintln(\"SPT schedule:         Cmax = $(Int(cmax(SPT)))\")\n\n# Generate a schedule using the Hochbaum-Shmoys algorithm\nHS = Algorithms.P__Cmax_HS(J, M, eps = 1//3)\nprintln(\"HS schedule:          Cmax = $(Int(cmax(HS)))\")\n\n# Plot the optimal schedule\nScheduling.plot(OPT)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The output will be:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Optimal schedule:     Cmax = 102\nLPT schedule:         Cmax = 104\nSPT schedule:         Cmax = 125\nHS schedule:          Cmax = 125","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and then the optimal plot will be generated by the PyPlot package.","category":"page"},{"location":"scheduling_machines/#Machines-1","page":"Machines","title":"Machines","text":"","category":"section"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"Another basic structure provided by the Scheduling.jl package is a Machine.","category":"page"},{"location":"scheduling_machines/#Creating-a-single-machine-1","page":"Machines","title":"Creating a single machine","text":"","category":"section"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"In order to create a machine, you may use the Machine constructor. Is is required to pass a machine name to the constructor, but all the other parameters are optional.","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"julia> Machine(\"M\")\nMachine M","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"Machine parameters can be set when the machine is created. However, as Machine is an immutable struct, you are not able to change any of the parameters of an existing job. Below we present all the possible parameters together with their default values:","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"struct Machine\n    name::String\n    s::Rational{UInt}   # speed (default: 1)\nend","category":"page"},{"location":"scheduling_machines/#Creating-a-set-of-machines-1","page":"Machines","title":"Creating a set of machines","text":"","category":"section"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"You are provided a few functions that can generate a vector of jobs. A vector of jobs is the basic structure any scheduling algorithm works on. You can create an empty vector of jobs, a vector of a given number of identical jobs or a vector of jobs with arbitrary processing times.","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"Machines()\nMachines(n::Int)\nMachines(P::Array{Rational{Int}, 1})\nMachines(P::Array{Int, 1})","category":"page"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{}","page":"Machines","title":"Scheduling.Machines","text":"Machines()\n\nGenerates an empty vector of Machine elements.\n\nExample\n\njulia> Machines()\nA set of 0 machine(s):\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{Int64}","page":"Machines","title":"Scheduling.Machines","text":"Machines(m::Int)\n\nGenerates a set of m identical parallel machines, denoted by P_1, P_2, etc.\n\nExample\n\njulia> Machines(4)\nA set of 4 machine(s):\n    Machine P_1\n    Machine P_2\n    Machine P_3\n    Machine P_4\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{Array{Rational{Int64},1}}","page":"Machines","title":"Scheduling.Machines","text":"Machines(S::Array{Rational{Int}, 1})\n\nGenerates a set of machines with speeds determined by the S array, denoted by Q_1, Q_2, etc.\n\nExample\n\njulia> Machines([1, 1//2, 2])\nA set of 3 machine(s):\n    Machine Q_1\n    Machine Q_2:     [s = 1//2]\n    Machine Q_3:     [s = 2]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#Scheduling.Machines-Tuple{Array{Int64,1}}","page":"Machines","title":"Scheduling.Machines","text":"Machines(S::Array{Int, 1})\n\nGenerates a set of machines with speeds determined by the S array, denoted by Q_1, Q_2, etc.\n\nExample\n\njulia> Machines([1, 3, 2])\nA set of 3 machine(s):\n    Machine Q_1\n    Machine Q_2:     [s = 3]\n    Machine Q_3:     [s = 2]\n\n\n\n\n\n\n","category":"method"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"As the set of machines is a vector of Machine elements, you may always extend it by a new one.","category":"page"},{"location":"scheduling_machines/#","page":"Machines","title":"Machines","text":"julia> M = Machines()\nA set of 0 machine(s):\n\njulia> push!(M, Machine(\"M\"))\nA set of 1 machine(s):\n    Machine M\n","category":"page"}]
}
